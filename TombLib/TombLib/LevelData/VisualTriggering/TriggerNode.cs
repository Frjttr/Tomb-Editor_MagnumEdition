using System.Collections.Generic;
using System.Numerics;
using TombLib.LevelData.VisualTriggering;

namespace TombLib.LevelData.VisualScripting
{

    // Every node in visual trigger has this set of parameters. Name and color are
    // merely UI properties, while Previous/Next and ScreenPosition determines the
    // order of compilation. Every node may have or may have no any previous or
    // next nodes. If node or group of nodes is orphaned, it's treated as a whole
    // code block. If visual trigger consists of several orphaned nodes or node
    // groups, they will be compiled into single function body in order determined
    // from their screen position: top to bottom.

    public abstract class TriggerNode
    {
        public string Name { get; set; }
        public Vector2 ScreenPosition { get; set; }
        public Vector3 Color { get; set; }

        public TriggerNode Previous { get; set; }
        public TriggerNode Next { get; set; }

        public bool AttachToNext(TriggerNode node)
        {
            if (node.Previous != null)
                return false;

            Next = node;
            node.Previous = this;
            return true;
        }

        public bool AttachToPrevious(TriggerNode node)
        {
            if (node.Next != null)
                return false;

            Previous = node;
            node.Next = this;
            return true;
        }

        public static void CleanUpNodes(List<TriggerNode> nodes)
        {
            var nodesToClean = new List<int>();

            for (int i = 0; i < nodes.Count; i++)
                if (nodes[i].Previous != null)
                    nodesToClean.Add(i);

            for (int i = nodesToClean.Count - 1; i >= 0; i--)
                nodes.RemoveAt(nodesToClean[i]);
        }
    }

    // Condition node uses a getter, which can be arbitrary code block,
    // but always should have a reserved __CONDVALUE string as a variable
    // to be replaced on compilation by arbitrary autogenerated name.
    // Else node is optional and allows to divert script to other branch.

    public class TriggerNodeCondition : TriggerNode
    {
        public ConditionType Type;
        public string Getter;

        public TriggerNode Else { get; set; }
    }

    // Action node is similar to simple event function call, apart from the
    // fact that it also embeds argument.

    public class TriggerNodeAction : TriggerNode
    {
        public string Function;
        public string Argument;
    }

    public class VisualTrigger
    {
        public List<TriggerNode> Nodes;
    }
}
